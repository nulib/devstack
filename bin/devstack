#!/usr/bin/env ruby

begin
  this_file = __FILE__
  this_file = File.readlink(this_file) while File.symlink?(this_file)
  $LOAD_PATH << File.expand_path('../../lib', this_file)
end
require 'yaml'
require 'pry'
require 'dev_stack'

DEFAULT_OPTIONS = { 'environment' => 'dev' }

module DevStack
  class CLI
    attr_reader :opts

    def initialize(opts)
      @opts = DEFAULT_OPTIONS.merge(load_defaults()).merge(opts)
    end

    def compose_file
      if @compose_file.nil?
        @compose_file = environment.file_path('docker-compose.yml').to_s
        File.open(@compose_file, 'w') do |file|
          file.write(stack.docker_compose_yaml(environment))
        end
      end
      @compose_file
    end

    def command_line
      (['docker-compose', '-f', compose_file] + ARGV).tap do |result|
        result << '-v' if ARGV[0] == 'down' && environment.destroy_volumes
      end
    end

    def environment
      @environment ||= DevStack::Environment.new YAML.load(environment_file(opts['environment']))
    end

    def stack
      if @stack.nil?
        stack_yaml = opts['stack'] ? stack_file(opts['stack']) : load_file(find_stack_file(File.expand_path('.')))
        @stack = DevStack::Stack.new YAML.load(stack_yaml)
      end
      @stack
    end

    def trap_cmd
      return [] unless ['up', '-d'] & ARGV == ['up']
      ['docker-compose', '-f', compose_file, 'down'].tap do |result|
        result << '-v' if environment.destroy_volumes
      end
    end
  
    def exec!
      ENV['COMPOSE_PROJECT_NAME'] ||= "devstack"
      ENV['COMPOSE_PROJECT_NAME'] = [ENV['COMPOSE_PROJECT_NAME'], environment.name].join('_')
      begin
        Kernel.system(*command_line)
      rescue Interrupt # rubocop:disable Lint/HandleExceptions
        # Let it go
      ensure
        final_cmd = trap_cmd
        Kernel.system(*final_cmd) unless final_cmd.empty?
      end
    end
  
    def environment_file(val)
      load_file(val, File.expand_path('environments', DevStack.root))
    end

    def stack_file(val)
      load_file(val, File.expand_path('stacks', DevStack.root))
    end

    def load_file(val, default_location = '.')
      return open(val).read if val.match?(/^https?:/)
      return open(val).read if File.exists?(val)
      path = File.join(default_location, val)
      path += '.yml' if File.extname(path).empty?
      return open(path).read if File.exists?(path)
    end

    def load_defaults
      devstack_file = find_devstack_file(File.expand_path('.'))
      return {} if devstack_file.nil? || !File.exists?(devstack_file)
      YAML.load(File.read(devstack_file))
    end

    def find_devstack_file(path)
      find_file_upstream(path, '.devstack')
    end

    def find_stack_file(path)
      find_file_upstream(path, '.stack')
    end

    def find_file_upstream(path, filename)
      candidate = File.join(path, filename)
      return candidate if File.exists?(candidate)
      return nil if path == '/' or path == ENV['HOME']
      return find_file_upstream(File.expand_path('..', path), filename)
    end
  end
end

case ARGV.first
when 'version', '-v', '--version'
  DevStack.display_version
when 'link'
  DevStack.link!
when 'update'
  DevStack.update!
else
  environment = ENV['DEVSTACK_ENV']
  if ARGV[0] == '-t'
    environment = 'test'
    ARGV.slice!(0)
  end
  stack = ENV['DEVSTACK_STACK']
  stack = ARGV.slice!(-1) if ARGV.length > 1 && ARGV.last.to_s !~ /^-/
  options = { 'environment' => environment, 'stack' => stack }.reject { |k,v| v.nil? }
  DevStack::CLI.new(options).exec!
end
